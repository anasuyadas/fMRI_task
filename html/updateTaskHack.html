
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><title>updateTaskHack</title><meta name="generator" content="MATLAB 7.10"><meta name="date" content="2014-10-20"><meta name="m-file" content="updateTaskHack"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">call eyetracker segment callback</a></li><li><a href="#4">call eyetracker endTrial callback</a></li><li><a href="#6">call eyetracker trial callback</a></li><li><a href="#8">call eyetracker block callback</a></li><li><a href="#10">call eyetracker trial callback</a></li></ul></div><pre class="codeinput"><span class="comment">% updateTask - update the task in running in stimulus programs</span>
<span class="comment">%</span>
<span class="comment">%        $Id: updateTask.m 1148 2014-06-09 08:21:12Z justin $</span>
<span class="comment">%      usage: [task, myscreen, tnum] = updateTask(task,myscreen,tnum)</span>
<span class="comment">%         by: justin gardner, eric dewitt</span>
<span class="comment">%       date: 2006-04-27</span>
<span class="comment">%  copyright: (c) 2006 Justin Gardner (GPL see mgl/COPYING)</span>
<span class="comment">%     inputs: stimulus,task,myscreen,tnum</span>
<span class="comment">%    outputs: stimulus task myscreen tnum</span>
<span class="comment">%    purpose: runs experimental tasks</span>
<span class="comment">%</span>
<span class="keyword">function</span> [task, myscreen, tnum] = updateTaskHack(task,myscreen,tnum)
<span class="keyword">global</span> stimulus
<span class="comment">% make sure we have a valid active task</span>
<span class="keyword">if</span> tnum &gt; length(task)
  <span class="keyword">return</span>
<span class="keyword">end</span>


<span class="comment">% set the random state</span>
randstate = rand(myscreen.randstate.type);
rand(task{tnum}.randstate.type,task{tnum}.randstate.state);

<span class="keyword">if</span> stimulus.FixationBreakCurrent &amp;&amp; ~stimulus.updateCurrent &amp;&amp; ~stimulus.upDated
            <span class="keyword">if</span> task{1}.numTrials == task{1}.origNumTrials
                n = 1;
            <span class="keyword">else</span>
                n = length(task{1}.fixBreakTrial)+1;
            <span class="keyword">end</span>
            task{1}.fixBreakTrial{n} = task{1}.thistrial;
            task{1}.numTrials = task{1}.origNumTrials + stimulus.numFixBreaks;
            task{1}.randVars.len_ = task{1}.numTrials;
            task{1}.randVars.trialIndex(task{1}.numTrials) = task{1}.randVars.trialIndex(task{1}.trialnum);
            stimulus.trialend = stimulus.trialend+1;
            stimulus.updateCurrent = 1;
            stimulus.upDated = 1;
<span class="keyword">elseif</span> stimulus.FixationBreakCurrent
    stimulus.upDated = 0;
<span class="keyword">end</span>




<span class="comment">% if we have finished how many trials were called for go to next task</span>
<span class="keyword">if</span> (task{tnum}.trialnum &gt; task{tnum}.numTrials)
  tnum = tnum+1;
  <span class="comment">% write out the phase</span>
  myscreen = writeTrace(tnum,task{tnum-1}.phaseTrace,myscreen);
  <span class="keyword">if</span> myscreen.eyetracker.init &amp;&amp; tnum &lt;= numel(task)
    [task{tnum} myscreen] = feval(myscreen.eyetracker.callback.nextTask,task{tnum},myscreen);
  <span class="keyword">end</span>
  [task myscreen tnum] = updateTask(task,myscreen,tnum);
  <span class="comment">% reset it to what it was before this call</span>
  rand(myscreen.randstate.type,randstate);
  <span class="keyword">return</span>
<span class="keyword">end</span>

<span class="comment">% check for a new block</span>
<span class="keyword">if</span> (task{tnum}.blocknum == 0) || (task{tnum}.blockTrialnum &gt; task{tnum}.block(task{tnum}.blocknum).trialn)
  <span class="comment">% if we have finished how many blocks were called for</span>
  <span class="comment">% then we need to go on to the next task</span>
  <span class="keyword">if</span> (task{tnum}.blocknum == task{tnum}.numBlocks)
    tnum = tnum+1;
    <span class="comment">% write out the phase</span>
    myscreen = writeTrace(tnum,task{tnum-1}.phaseTrace,myscreen);
    <span class="keyword">if</span> myscreen.eyetracker.init &amp;&amp; tnum &lt;= numel(task)
      [task{tnum} myscreen] = feval(myscreen.eyetracker.callback.nextTask,task{tnum},myscreen);
    <span class="keyword">end</span>
    [task myscreen tnum] = updateTask(task, myscreen, tnum);
    <span class="comment">% reset it to what it was before this call</span>
    rand(myscreen.randstate.type,randstate);
    <span class="keyword">return</span>
  <span class="keyword">end</span>
  <span class="comment">% otherwise init a new block and continue on</span>
  [task{tnum} myscreen] = initBlock(task{tnum},myscreen,tnum);
<span class="keyword">end</span>

<span class="comment">% update trial</span>
[task myscreen tnum] = updateTrial(task, myscreen, tnum);

<span class="comment">% remember the status of the random number generator</span>
<span class="keyword">if</span> tnum&lt;=length(task) &amp; isfield(task{tnum},<span class="string">'randstate'</span>)
  task{tnum}.randstate.state = rand(task{tnum}.randstate.type);
<span class="keyword">end</span>
rand(myscreen.randstate.type,randstate);


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% update trial</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> [task, myscreen tnum] = updateTrial(task, myscreen, tnum)

<span class="keyword">if</span> task{tnum}.thistrial.waitingToInit
  <span class="comment">% init the trial</span>
  [task{tnum} myscreen] = initTrial(task{tnum},myscreen,tnum);
<span class="keyword">end</span>

<span class="comment">% get globals</span>
<span class="keyword">global</span> stimulus;

<span class="comment">% see if we are waiting for backtick</span>
<span class="keyword">if</span> task{tnum}.thistrial.segstart == -inf
  <span class="keyword">if</span> task{tnum}.thistrial.waitForBacktick
    <span class="comment">% only continue if we have received a backtick</span>
    <span class="keyword">if</span> myscreen.volnum == task{tnum}.thistrial.startvolnum
      <span class="keyword">return</span>
    <span class="keyword">else</span>
      disp(sprintf(<span class="string">'(updateTask) Backtick recorded: Starting trial'</span>));
      <span class="comment">% clear waiting status</span>
      task{tnum}.thistrial.waitForBacktick = 0;
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="comment">% write out appropriate trace</span>
  myscreen = writeTrace(1,task{tnum}.segmentTrace,myscreen,1);
  <span class="comment">% restart segment clock and continue on</span>
  <span class="comment">% as if the segment just started</span>
  <span class="keyword">if</span> task{tnum}.timeInTicks
    task{tnum}.thistrial.trialstart = myscreen.tick;
  <span class="keyword">elseif</span> task{tnum}.timeInVols
    task{tnum}.thistrial.trialstart = myscreen.volnum;
  <span class="keyword">else</span>
    thistime = mglGetSecs;
    <span class="comment">% calculate trial time discrepancy</span>
    <span class="keyword">if</span> task{tnum}.trialnum &gt; 1
      <span class="comment">% info for the last trial is in lasttrial, so find the</span>
      <span class="comment">% difference between the time the trial actually took</span>
      <span class="comment">% and how long it was expected to take-how much time</span>
      <span class="comment">% we had to make up</span>
      task{tnum}.timeDiscrepancy = (thistime-task{tnum}.lasttrial.trialstart)-(sum(task{tnum}.lasttrial.seglen)-task{tnum}.timeDiscrepancy);
    <span class="keyword">end</span>
    task{tnum}.thistrial.trialstart = thistime;
  <span class="keyword">end</span>
  task{tnum} = resetSegmentClock(task{tnum},myscreen);
  <span class="comment">% call segment start callback</span>
  [task{tnum} myscreen] = feval(task{tnum}.callback.startSegment,task{tnum},myscreen);
  <span class="keyword">if</span> myscreen.eyetracker.init
</pre><h2>call eyetracker segment callback<a name="2"></a></h2><pre class="codeinput">    [task{tnum} myscreen] = feval(myscreen.eyetracker.callback.startSegment,task{tnum},myscreen);
</pre><pre class="codeinput">  <span class="keyword">end</span>

  <span class="comment">% if this segment is set to getResponse(2), then it means that we</span>
  <span class="comment">% are getting response and shutting down flipping of the screen</span>
  <span class="comment">% so that we can get better response time for reaction time tasks</span>
  <span class="keyword">if</span> (task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==2)
    <span class="comment">% call the display function now, and flush screen</span>
    <span class="comment">%[task{tnum} myscreen] = feval(task{tnum}.callback.screenUpdate,task{tnum},myscreen);</span>
    <span class="comment">%mglFlush;</span>
    <span class="comment">% now set not to update the screen while we wait for response</span>
    myscreen.oldFlushMode = myscreen.flushMode;
    myscreen.flushMode = 1;
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% check to see if we have gone over segment time</span>
segover = 0;

<span class="comment">% check end of segment in ticks</span>
<span class="keyword">if</span> task{tnum}.timeInTicks == 1
  <span class="keyword">if</span> (myscreen.tick - task{tnum}.thistrial.segstart) &gt;= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
    segover = 1;
  <span class="keyword">end</span>
  <span class="comment">% or the number of ticks</span>
<span class="keyword">elseif</span> task{tnum}.timeInVols
  <span class="keyword">if</span> (myscreen.volnum - task{tnum}.thistrial.segstart) &gt;= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
    segover = 1;
  <span class="keyword">end</span>
  <span class="comment">% check end of segment in seconds</span>
<span class="keyword">else</span>
  <span class="keyword">if</span> (mglGetSecs-task{tnum}.thistrial.segstart) &gt;= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
    <span class="comment">% if we need to synch to volume</span>
    <span class="keyword">if</span> task{tnum}.synchToVol(task{tnum}.thistrial.thisseg)
      <span class="comment">% then first time through set the volume number</span>
      <span class="keyword">if</span> task{tnum}.thistrial.synchVol == -1
	task{tnum}.thistrial.synchVol = myscreen.volnum;
	<span class="comment">% then see if we have gone past that volume</span>
      <span class="keyword">elseif</span> task{tnum}.thistrial.synchVol &lt; myscreen.volnum
	segover = 1;
	<span class="comment">% reset the segment time to match how much time elapsed</span>
	<span class="comment">% so that the next segment won't be shortened</span>
	task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg) = mglGetSecs-task{tnum}.thistrial.segstart;
      <span class="keyword">end</span>
      <span class="comment">%w/out synch to volume the segment is over</span>
    <span class="keyword">else</span>
      segover = 1;
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% there are situations in which for the trial in the sequence</span>
<span class="comment">% we are waiting for a volume to end the trial, but will enver</span>
<span class="comment">% get one since the scan is over. Yet, we still want to end the</span>
<span class="comment">% trial to end the experiment, so we are going to have fudge</span>
<span class="comment">% on the last volume.</span>
<span class="keyword">if</span> task{tnum}.fudgeLastVolume
  <span class="comment">% see if we are in the last trial for numTrials, or the</span>
  <span class="comment">% last trial of the last block for numBlocks</span>
  <span class="keyword">if</span> (task{tnum}.trialnum == task{tnum}.numTrials) || <span class="keyword">...</span>
	((task{tnum}.blocknum == task{tnum}.numBlocks) &amp;&amp; (task{tnum}.blockTrialnum == task{tnum}.block(task{tnum}.blocknum).trialn))
    <span class="keyword">if</span> ~isfield(task{tnum}.thistrial,<span class="string">'fudgeLastVolume'</span>)
      <span class="comment">% see if we are in the last segment</span>
      <span class="keyword">if</span> task{tnum}.thistrial.thisseg == length(task{tnum}.thistrial.seglen)
	<span class="comment">% make sure we have satisfied all but the last volume</span>
	<span class="comment">% for the trial (this could either be due to a synchToVol</span>
	<span class="comment">% waiting for the volume to end, or with timeInVols we have</span>
	<span class="comment">% gotten all but the last volume</span>
	segmentExpired = 0;
	<span class="keyword">if</span> task{tnum}.synchToVol(task{tnum}.thistrial.thisseg)
	  <span class="keyword">if</span> task{tnum}.timeInTicks == 1
	    <span class="keyword">if</span> (myscreen.tick - task{tnum}.thistrial.segstart) &gt;= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
	      segmentExpired = 1;
	    <span class="keyword">end</span>
	    <span class="comment">% check end of segment in seconds</span>
	  <span class="keyword">else</span>
	    <span class="keyword">if</span> (mglGetSecs-task{tnum}.thistrial.segstart) &gt;= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
	      segmentExpired = 1;
	    <span class="keyword">end</span>
	  <span class="keyword">end</span>
	<span class="keyword">else</span>
	  <span class="comment">% check number of volumes</span>
	  <span class="keyword">if</span> task{tnum}.timeInVols
	    <span class="keyword">if</span> ((myscreen.volnum - task{tnum}.thistrial.segstart)+1) &gt;= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
	      segmentExpired = 1;
	    <span class="keyword">end</span>
	  <span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="comment">% if segmentExpired gets set then it means that the segment has ended and</span>
	<span class="comment">% is just waiting for the volume (which will never come, so now we</span>
	<span class="comment">% set the fudgeLastVolume field so that it will end at 1 average volume</span>
	<span class="comment">% time away from now.</span>
	<span class="keyword">if</span> segmentExpired
	  <span class="comment">% find the average volume time</span>
	  volumeTimes = myscreen.events.time((myscreen.events.data == 1) &amp; (myscreen.events.tracenum==1));
	  <span class="comment">% we will only do this correction, if we can get</span>
	  <span class="comment">% a valid averageVolume Time</span>
	  <span class="keyword">if</span> ~isempty(volumeTimes)
	    <span class="comment">% get time of last volume</span>
	    task{tnum}.thistrial.averageVolumeTime = mean(diff(volumeTimes));
	    task{tnum}.thistrial.fudgeLastVolume = volumeTimes(end)+task{tnum}.thistrial.averageVolumeTime;
	  <span class="keyword">end</span>
	<span class="keyword">end</span>
      <span class="keyword">end</span>
      <span class="comment">% if there is a fudgeLastVolume field then it means</span>
      <span class="comment">% we should end the segment, once the proper amount of time has elapsed</span>
      <span class="comment">% this is the actual piece of code in here which causes the</span>
      <span class="comment">% segment to end by setting segover to 1</span>
    <span class="keyword">else</span>
      <span class="keyword">if</span> mglGetSecs &gt; task{tnum}.thistrial.fudgeLastVolume
	disp(sprintf(<span class="string">'(updateTask) Used fudgeLastVolume to end last trial of task (averageVolumeTime=%0.2f)'</span>,task{tnum}.thistrial.averageVolumeTime));
	segover = 1;
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% update the segment if necessary</span>
<span class="keyword">if</span> (segover)
  <span class="comment">% reset flush mode if we just finished a reactionTime response interval</span>
  <span class="keyword">if</span> (task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==2)
    myscreen.flushMode = myscreen.oldFlushMode;
  <span class="keyword">end</span>
  <span class="comment">% now update segment counter</span>
  task{tnum}.thistrial.thisseg = task{tnum}.thistrial.thisseg + 1;
  <span class="comment">% if we have completed all segments then we are done</span>
  <span class="keyword">if</span> (task{tnum}.thistrial.thisseg &gt; length(task{tnum}.thistrial.seglen))
    <span class="comment">% end the current trial</span>
    <span class="keyword">if</span> isfield(task{tnum}.callback,<span class="string">'endTrial'</span>)
      [task{tnum} myscreen]= feval(task{tnum}.callback.endTrial,task{tnum},myscreen);
    <span class="keyword">end</span>
    <span class="keyword">if</span> myscreen.eyetracker.init
</pre><h2>call eyetracker endTrial callback<a name="4"></a></h2><pre class="codeinput">      [task{tnum} myscreen] = feval(myscreen.eyetracker.callback.endTrial,task{tnum},myscreen);
</pre><pre class="codeinput">    <span class="keyword">end</span>
    <span class="comment">% if there are calculated random variables, save them</span>
    <span class="keyword">if</span> task{tnum}.randVars.calculated_n_
      <span class="keyword">for</span> nVar = 1:task{tnum}.randVars.calculated_n_
	<span class="comment">% check to make sure that the value in the calculated variable is not</span>
	<span class="comment">% set to empty (if it is, then we warn and ignore), otherwise</span>
	<span class="comment">% we set the stored calculated variable was set to (in the user</span>
	<span class="comment">% program) in task.thistrial</span>
	<span class="keyword">if</span> ~isempty(task{tnum}.thistrial.(task{tnum}.randVars.calculated_names_{nVar}))
	  <span class="keyword">if</span> isscalar(task{tnum}.thistrial.(task{tnum}.randVars.calculated_names_{nVar}))
	    <span class="comment">% scalar calculated var gets an array</span>
	    eval(sprintf(<span class="string">'task{tnum}.randVars.%s(task{tnum}.trialnum) = task{tnum}.thistrial.%s;'</span>,task{tnum}.randVars.calculated_names_{nVar},task{tnum}.randVars.calculated_names_{nVar}));
	  <span class="keyword">else</span>
	    <span class="comment">% non-scalar calculated var gets a *cell* array</span>
	    eval(sprintf(<span class="string">'task{tnum}.randVars.%s{task{tnum}.trialnum} = task{tnum}.thistrial.%s;'</span>,task{tnum}.randVars.calculated_names_{nVar},task{tnum}.randVars.calculated_names_{nVar}));
	  <span class="keyword">end</span>
	<span class="keyword">else</span>
	  disp(sprintf(<span class="string">'(updateTask) !!! randVar %s set to empty for trial %i, leaving as default value of %s'</span>,task{tnum}.randVars.calculated_names_{nVar},task{tnum}.trialnum,task{tnum}.randVars.(task{tnum}.randVars.calculated_names_{nVar})(task{tnum}.trialnum)));
	<span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% we collect the calculated randVars from thistrial and place them</span>
    <span class="comment">% back into the randVar array.</span>
    <span class="comment">% this</span>
    <span class="comment">% update the trial number</span>
    task{tnum}.blockTrialnum = task{tnum}.blockTrialnum + 1;
    task{tnum}.trialnum = task{tnum}.trialnum+1;
    <span class="comment">% set the trial to init when it hits updateTrial again</span>
    <span class="comment">% (this will happen from the updateTask called below)</span>
    task{tnum}.thistrial.waitingToInit = 1;
    <span class="comment">% now we have to update the task</span>
    [task myscreen tnum] = updateTask(task,myscreen,tnum);
    <span class="comment">% make sure that random number generator is in correct state</span>
    <span class="keyword">if</span> tnum&lt;=length(task) &amp; isfield(task{tnum},<span class="string">'randstate'</span>)
      rand(task{tnum}.randstate.type,task{tnum}.randstate.state);
    <span class="keyword">end</span>
    <span class="keyword">return</span>
  <span class="keyword">end</span>
  <span class="comment">% restart segment clock</span>
  task{tnum} = resetSegmentClock(task{tnum},myscreen);
  <span class="comment">% write out appropriate trace</span>
  myscreen = writeTrace(task{tnum}.thistrial.thisseg,task{tnum}.segmentTrace,myscreen,1);

  <span class="comment">% call segment start callback</span>
  <span class="keyword">if</span> myscreen.eyetracker.init
</pre><h2>call eyetracker trial callback<a name="6"></a></h2><pre class="codeinput">    [task{tnum} myscreen] = feval(myscreen.eyetracker.callback.startSegment,task{tnum},myscreen);
</pre><pre class="codeinput">  <span class="keyword">end</span>
  [task{tnum} myscreen] = feval(task{tnum}.callback.startSegment,task{tnum},myscreen);
  <span class="comment">% if this segment is set to getResponse(2), then it means that we</span>
  <span class="comment">% are getting response and shutting down flipping of the screen</span>
  <span class="comment">% so that we can get better response time for reaction time tasks</span>
  <span class="keyword">if</span> (task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==2)
    <span class="comment">% call the display funciton now, and flush screen</span>
    [task{tnum} myscreen] = feval(task{tnum}.callback.screenUpdate,task{tnum},myscreen);
    mglFlush;
    <span class="comment">% now set not update the screen while we wait for response</span>
    myscreen.oldFlushMode = myscreen.flushMode;
    myscreen.flushMode = -1;
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% if we have to collect observer response, then look for that</span>
<span class="keyword">if</span> (task{tnum}.getResponse(task{tnum}.thistrial.thisseg))
  <span class="comment">% check keyboard if that is what is being asked for (code 1 or 2) 1</span>
  <span class="comment">% is just keyboard check 2 is an old call for checking keyboard but</span>
  <span class="comment">% staying in a tight loop for gettine better reaction time data (not</span>
  <span class="comment">% necessary anymore because the keyboard events are being returned</span>
  <span class="comment">% by the system with nanosecond precision timing. 3 means get both</span>
  <span class="comment">% keyboard and mouse events and 4 means just mouse</span>
  task{tnum}.thistrial.mouseButton = [];
  <span class="comment">% get keyboard state</span>
  buttons = ismember(myscreen.keyboard.nums,myscreen.keyCodes);
  <span class="keyword">if</span> any(task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==[1 2 3])
    <span class="comment">% if a button was pressed, then record response</span>
    <span class="keyword">if</span> (any(buttons) &amp;&amp; (~isequal(buttons,task{tnum}.thistrial.buttonState)))
      <span class="comment">% set the button state to pass</span>
      task{tnum}.thistrial.buttonState = buttons;
      task{tnum}.thistrial.whichButton = find(buttons);
      task{tnum}.thistrial.whichButton = task{tnum}.thistrial.whichButton(1);
      <span class="comment">% get the time of the button press</span>
      whichKeyCode = find(myscreen.keyboard.nums(task{tnum}.thistrial.whichButton)==myscreen.keyCodes);
      responseTime = myscreen.keyTimes(whichKeyCode(1));
      <span class="comment">% write out an event</span>
      myscreen = writeTrace(task{tnum}.thistrial.whichButton,task{tnum}.responseTrace,myscreen,1,responseTime);
      <span class="comment">% get reaction time</span>
      task{tnum}.thistrial.reactionTime = responseTime-task{tnum}.thistrial.segStartSeconds;
      <span class="keyword">if</span> isfield(task{tnum}.callback,<span class="string">'trialResponse'</span>)
	[task{tnum} myscreen] = feval(task{tnum}.callback.trialResponse,task{tnum},myscreen);
      <span class="keyword">end</span>
      <span class="comment">% set flush mode back</span>
      <span class="keyword">if</span> (task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==2)
	myscreen.flushMode = myscreen.oldFlushMode;
      <span class="keyword">end</span>
      <span class="comment">% and set that we have got a response</span>
      task{tnum}.thistrial.gotResponse = task{tnum}.thistrial.gotResponse+1;
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="comment">% remember the current button state</span>
  task{tnum}.thistrial.buttonState = buttons;
  <span class="comment">% check mouse state if getResponse is set to 3</span>
  <span class="keyword">if</span> any(task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==[3 4])
    <span class="comment">% get the mouse state</span>
    [task{tnum}.thistrial.mouseButton task{tnum}.thistrial.mouseWhen task{tnum}.thistrial.mouseX task{tnum}.thistrial.mouseY] = mglGetMouseEvent(0,1);
    <span class="comment">% remove events that happened before this segment</span>
    goodEvents = task{tnum}.thistrial.mouseWhen &gt; task{tnum}.thistrial.segStartSeconds;
    <span class="keyword">if</span> ~isempty(task{tnum}.thistrial.mouseButton)
      task{tnum}.thistrial.mouseButton = task{tnum}.thistrial.mouseButton(goodEvents);
      task{tnum}.thistrial.mouseWhen = task{tnum}.thistrial.mouseWhen(goodEvents);
      task{tnum}.thistrial.mouseX = task{tnum}.thistrial.mouseX(goodEvents);
      task{tnum}.thistrial.mouseY = task{tnum}.thistrial.mouseY(goodEvents);
    <span class="keyword">end</span>
    <span class="comment">% if there was a mouse down event</span>
    <span class="keyword">if</span> ~isempty(task{tnum}.thistrial.mouseButton)
      responseTime = task{tnum}.thistrial.mouseWhen;
      <span class="comment">% write out an event (code the mouse events as negative numbers to</span>
      <span class="comment">% distinguish them from keyboard events</span>
      myscreen = writeTrace(-task{tnum}.thistrial.mouseButton,task{tnum}.responseTrace,myscreen,1,responseTime);
      <span class="comment">% get reaction time</span>
      task{tnum}.thistrial.reactionTime = responseTime-task{tnum}.thistrial.segStartSeconds;
      <span class="keyword">if</span> isfield(task{tnum}.callback,<span class="string">'trialResponse'</span>)
	[task{tnum} myscreen] = feval(task{tnum}.callback.trialResponse,task{tnum},myscreen);
      <span class="keyword">end</span>
      <span class="comment">% and set that we have got a response</span>
      task{tnum}.thistrial.gotResponse = task{tnum}.thistrial.gotResponse+1;
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% update the stimuli, but only if we are actually updating the screen</span>
<span class="keyword">if</span> myscreen.flushMode &gt;= 0
  [task{tnum} myscreen] = feval(task{tnum}.callback.screenUpdate,task{tnum},myscreen);
<span class="keyword">end</span>


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% init block</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> [task myscreen] = initBlock(task,myscreen,phase)

<span class="comment">% start up a new block</span>
<span class="comment">% select a randomization of trial parameters</span>
task.blocknum = task.blocknum+1;

<span class="comment">% set the randstate here. This is so that the randomization that</span>
<span class="comment">% happens here is independent of other uses of the rand variable</span>
<span class="comment">% that way if you want to recreate the order of trials, you</span>
<span class="comment">% can reset the rand state in initTask from the one that is saved</span>
randstate = rand(task.randstate.type);
rand(task.randstate.type,task.randstate.blockState);

<span class="comment">% update the parameter order for this block</span>
<span class="comment">% using the randomization callback, if this</span>
<span class="comment">% pass previous block if it is available</span>
<span class="keyword">if</span> task.blocknum &gt; 1
  task.block(task.blocknum) = feval(task.callback.rand,task.parameter,task.block(task.blocknum-1));
<span class="keyword">else</span>
  task.block(task.blocknum) = feval(task.callback.rand,task.parameter,[]);
<span class="keyword">end</span>

<span class="comment">% now keep the randstate</span>
task.randstate.blockState = rand(task.randstate.type);
rand(task.randstate.type,randstate);

<span class="comment">% set the initial trial</span>
task.blockTrialnum = 1;

<span class="comment">% call the init block callback</span>
<span class="keyword">if</span> isfield(task.callback,<span class="string">'startBlock'</span>)
  [task myscreen] = feval(task.callback.startBlock,task,myscreen);
<span class="keyword">end</span>
<span class="keyword">if</span> myscreen.eyetracker.init
</pre><h2>call eyetracker block callback<a name="8"></a></h2><pre class="codeinput">  [task myscreen] = feval(myscreen.eyetracker.callback.startBlock,task,myscreen);
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="comment">% set up start time to tell routines to init trial properly</span>
<span class="comment">% only init new trials if the number of trials is less than or equal to</span>
<span class="comment">% orig trials</span>

[task myscreen] = initTrial(task,myscreen,phase);


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% init trial</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> [task, myscreen] = initTrial(task,myscreen,phase)

<span class="comment">% keep lasttrial information</span>
task.lasttrial = task.thistrial;

<span class="comment">%only update randvars if this is a new trial and not a trial that is been</span>
<span class="comment">% if task.trialnum &lt;= task.origNumTrials</span>
    <span class="comment">% get randomization parameters</span>
    <span class="keyword">for</span> i = 1:task.randVars.n_
        <span class="comment">% get the variable name we are working on</span>
        thisRandVarName = task.randVars.names_{i};
        <span class="keyword">if</span> iscell(task.randVars.(thisRandVarName))
            <span class="comment">% if the precomputed list is a cell array then grab from that cell array</span>
            task.thistrial.(thisRandVarName) = task.randVars.(thisRandVarName){mod(task.trialnum-1,task.randVars.varlen_(i))+1};
        <span class="keyword">else</span>
            <span class="comment">% otherwise grab from a regular array</span>
            task.thistrial.(thisRandVarName) = task.randVars.(thisRandVarName)(mod(task.trialnum-1,task.randVars.varlen_(i))+1);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="comment">% else</span>
<span class="comment">%     task.thistrial = task.fixBreakTrial(stimulus.trialnum-task.origNumTrials);</span>
<span class="comment">% end</span>

<span class="comment">% recreate all other trialvars regardless of whether this is a new or a</span>
<span class="comment">% reused trial</span>

<span class="comment">% set the phase num of the trial</span>
task.thistrial.thisphase = phase;

<span class="comment">% set the segment number</span>
task.thistrial.thisseg = 1;
task.thistrial.gotResponse = 0;

<span class="comment">% restart segment clock</span>
task.thistrial.segstart = -inf;

<span class="comment">% start trial time</span>
<span class="comment">%if (task.timeInTicks)</span>
<span class="comment">%  task.thistrial.trialstart = myscreen.tick;</span>
<span class="comment">%elseif (task.timeInVols)</span>
<span class="comment">%  task.thistrial.trialstart = myscreen.volnum;</span>
<span class="comment">%else</span>
<span class="comment">%end</span>

<span class="comment">% set up start volume for checking for backticks</span>
task.thistrial.startvolnum = myscreen.volnum;


<span class="comment">% here we deal with precomputed seglen</span>
<span class="keyword">if</span> isequal(task.seglenPrecompute,false)
    <span class="comment">% set the segment length</span>
    [seglen task] = getTaskSeglen(task);
    task.thistrial.seglen = seglen;
<span class="keyword">else</span>
    <span class="comment">% note that if seglens are precomputed, also anything else having to do</span>
    <span class="comment">% with semgents need to be recomputed (i.e. you may want to compute</span>
    <span class="comment">% synchToVol or getResponse on a trial by trial basis - for example,</span>
    <span class="comment">% you may have trials in which on different trials the synchToVol changes</span>
    <span class="comment">% or which segment is the response segment changes.Whatever fields</span>
    <span class="comment">% there are in seglenPrecompute get placed into task at this stage</span>
    <span class="keyword">for</span> iField = 1:task.seglenPrecompute.nFields
        <span class="comment">% get the name of the field getting set from precompute</span>
        fieldName = (task.seglenPrecompute.fieldNames{iField});
        <span class="comment">% get what cell to take (i.e. if the field only has one row</span>
        <span class="comment">% then we will take that otherwise there should be one cell for</span>
        <span class="comment">% each trial) If we have multiple trials, but less than the current</span>
        <span class="comment">% trial number than cycle through the rows</span>
        fieldRow = mod(task.trialnum-1,task.seglenPrecompute.(fieldName).nTrials)+1;
        task.thistrial.(fieldName) = task.seglenPrecompute.(fieldName).vals{fieldRow};
    <span class="keyword">end</span>
    <span class="comment">% now get the seglen for this trial (note that seglen is a cell array</span>
    <span class="comment">% which allows for trials with different numbers of segments)</span>
    fieldRow = mod(task.trialnum-1,task.seglenPrecompute.seglen.nTrials)+1;
    task.thistrial.seglen = task.seglenPrecompute.seglen.vals{fieldRow};
<span class="keyword">end</span>


<span class="comment">% see if we need to wait for backtick</span>
<span class="keyword">if</span> task.waitForBacktick &amp;&amp; (task.blocknum == 1) &amp;&amp; (task.blockTrialnum == 1)
  task.thistrial.waitForBacktick = 1;
  backtick = mglKeycodeToChar(myscreen.keyboard.backtick);
  disp(sprintf(<span class="string">'(updateTask) Waiting for backtick (%s)'</span>,backtick{1}));
<span class="keyword">else</span>
  <span class="comment">% trial will start right awway</span>
  task.thistrial.waitForBacktick = 0;
<span class="keyword">end</span>

<span class="comment">% set the button states to zero</span>
task.thistrial.buttonState = [0 0];

<span class="comment">% get trial parameters</span>
<span class="keyword">for</span> i = 1:task.parameter.n_
  eval(sprintf(<span class="string">'task.thistrial.%s = task.block(task.blocknum).parameter.%s(:,task.blockTrialnum);'</span>,task.parameter.names_{i},task.parameter.names_{i}));
<span class="keyword">end</span>


<span class="comment">% call the init trial callback</span>
<span class="keyword">if</span> isfield(task.callback,<span class="string">'startTrial'</span>)
  [task myscreen] = feval(task.callback.startTrial,task,myscreen);
<span class="keyword">end</span>
<span class="keyword">if</span> myscreen.eyetracker.init
</pre><h2>call eyetracker trial callback<a name="10"></a></h2><pre class="codeinput">  [task myscreen] = feval(myscreen.eyetracker.callback.startTrial,task,myscreen);
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="comment">% the trial is no longer waiting to start</span>
task.thistrial.waitingToInit = 0;


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% function to reset segment time</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="keyword">function</span> task = resetSegmentClock(task,myscreen)

<span class="comment">% reset the synch volume</span>
task.thistrial.synchVol = -1;

<span class="comment">% get amount of time already used, including and</span>
<span class="comment">% discrepancy left over from last trial</span>
usedtime = sum(task.thistrial.seglen(1:(task.thistrial.thisseg-1)));

<span class="comment">% restart segment clock, if we are using seconds, then fix</span>
<span class="comment">% any time discrepancy</span>
<span class="keyword">if</span> ~(task.timeInVols || task.timeInTicks)
  task.thistrial.segstart = task.thistrial.trialstart-task.timeDiscrepancy+usedtime;
<span class="keyword">else</span>
  task.thistrial.segstart = task.thistrial.trialstart+usedtime;
<span class="keyword">end</span>
<span class="comment">% get start of segment in real seconds</span>
task.thistrial.segStartSeconds = mglGetSecs;
</pre><pre class="codeoutput">Input argument "tnum" is undefined.

Error in ==&gt; updateTaskHack at 15
if tnum &gt; length(task)
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.10<br></p></div><!--
##### SOURCE BEGIN #####
% updateTask - update the task in running in stimulus programs
%
%        $Id: updateTask.m 1148 2014-06-09 08:21:12Z justin $
%      usage: [task, myscreen, tnum] = updateTask(task,myscreen,tnum)
%         by: justin gardner, eric dewitt
%       date: 2006-04-27
%  copyright: (c) 2006 Justin Gardner (GPL see mgl/COPYING)
%     inputs: stimulus,task,myscreen,tnum
%    outputs: stimulus task myscreen tnum
%    purpose: runs experimental tasks
%
function [task, myscreen, tnum] = updateTaskHack(task,myscreen,tnum)
global stimulus
% make sure we have a valid active task
if tnum > length(task)
  return
end


% set the random state
randstate = rand(myscreen.randstate.type);
rand(task{tnum}.randstate.type,task{tnum}.randstate.state);

if stimulus.FixationBreakCurrent && ~stimulus.updateCurrent && ~stimulus.upDated
            if task{1}.numTrials == task{1}.origNumTrials
                n = 1;
            else
                n = length(task{1}.fixBreakTrial)+1;
            end
            task{1}.fixBreakTrial{n} = task{1}.thistrial;
            task{1}.numTrials = task{1}.origNumTrials + stimulus.numFixBreaks;
            task{1}.randVars.len_ = task{1}.numTrials;
            task{1}.randVars.trialIndex(task{1}.numTrials) = task{1}.randVars.trialIndex(task{1}.trialnum);
            stimulus.trialend = stimulus.trialend+1;
            stimulus.updateCurrent = 1; 
            stimulus.upDated = 1;
elseif stimulus.FixationBreakCurrent
    stimulus.upDated = 0;
end




% if we have finished how many trials were called for go to next task
if (task{tnum}.trialnum > task{tnum}.numTrials)
  tnum = tnum+1;
  % write out the phase
  myscreen = writeTrace(tnum,task{tnum-1}.phaseTrace,myscreen);
  if myscreen.eyetracker.init && tnum <= numel(task)
    [task{tnum} myscreen] = feval(myscreen.eyetracker.callback.nextTask,task{tnum},myscreen);
  end
  [task myscreen tnum] = updateTask(task,myscreen,tnum);
  % reset it to what it was before this call
  rand(myscreen.randstate.type,randstate);
  return
end

% check for a new block
if (task{tnum}.blocknum == 0) || (task{tnum}.blockTrialnum > task{tnum}.block(task{tnum}.blocknum).trialn) 
  % if we have finished how many blocks were called for
  % then we need to go on to the next task
  if (task{tnum}.blocknum == task{tnum}.numBlocks)
    tnum = tnum+1;
    % write out the phase
    myscreen = writeTrace(tnum,task{tnum-1}.phaseTrace,myscreen);
    if myscreen.eyetracker.init && tnum <= numel(task)
      [task{tnum} myscreen] = feval(myscreen.eyetracker.callback.nextTask,task{tnum},myscreen);
    end
    [task myscreen tnum] = updateTask(task, myscreen, tnum);
    % reset it to what it was before this call
    rand(myscreen.randstate.type,randstate);
    return
  end
  % otherwise init a new block and continue on
  [task{tnum} myscreen] = initBlock(task{tnum},myscreen,tnum);
end

% update trial
[task myscreen tnum] = updateTrial(task, myscreen, tnum);

% remember the status of the random number generator
if tnum<=length(task) & isfield(task{tnum},'randstate') 
  task{tnum}.randstate.state = rand(task{tnum}.randstate.type);
end
rand(myscreen.randstate.type,randstate);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% update trial
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [task, myscreen tnum] = updateTrial(task, myscreen, tnum)

if task{tnum}.thistrial.waitingToInit
  % init the trial
  [task{tnum} myscreen] = initTrial(task{tnum},myscreen,tnum);
end

% get globals
global stimulus;

% see if we are waiting for backtick
if task{tnum}.thistrial.segstart == -inf
  if task{tnum}.thistrial.waitForBacktick
    % only continue if we have received a backtick
    if myscreen.volnum == task{tnum}.thistrial.startvolnum
      return
    else
      disp(sprintf('(updateTask) Backtick recorded: Starting trial'));
      % clear waiting status
      task{tnum}.thistrial.waitForBacktick = 0;
    end
  end
  % write out appropriate trace
  myscreen = writeTrace(1,task{tnum}.segmentTrace,myscreen,1);
  % restart segment clock and continue on
  % as if the segment just started
  if task{tnum}.timeInTicks
    task{tnum}.thistrial.trialstart = myscreen.tick;
  elseif task{tnum}.timeInVols
    task{tnum}.thistrial.trialstart = myscreen.volnum;
  else
    thistime = mglGetSecs;
    % calculate trial time discrepancy
    if task{tnum}.trialnum > 1
      % info for the last trial is in lasttrial, so find the
      % difference between the time the trial actually took
      % and how long it was expected to take-how much time
      % we had to make up 
      task{tnum}.timeDiscrepancy = (thistime-task{tnum}.lasttrial.trialstart)-(sum(task{tnum}.lasttrial.seglen)-task{tnum}.timeDiscrepancy);
    end
    task{tnum}.thistrial.trialstart = thistime;
  end
  task{tnum} = resetSegmentClock(task{tnum},myscreen);
  % call segment start callback
  [task{tnum} myscreen] = feval(task{tnum}.callback.startSegment,task{tnum},myscreen);
  if myscreen.eyetracker.init 
    %% call eyetracker segment callback
    [task{tnum} myscreen] = feval(myscreen.eyetracker.callback.startSegment,task{tnum},myscreen);
  end

  % if this segment is set to getResponse(2), then it means that we 
  % are getting response and shutting down flipping of the screen
  % so that we can get better response time for reaction time tasks
  if (task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==2)
    % call the display function now, and flush screen
    %[task{tnum} myscreen] = feval(task{tnum}.callback.screenUpdate,task{tnum},myscreen);
    %mglFlush;
    % now set not to update the screen while we wait for response
    myscreen.oldFlushMode = myscreen.flushMode;
    myscreen.flushMode = 1;
  end
end

% check to see if we have gone over segment time
segover = 0;

% check end of segment in ticks
if task{tnum}.timeInTicks == 1
  if (myscreen.tick - task{tnum}.thistrial.segstart) >= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
    segover = 1;
  end
  % or the number of ticks
elseif task{tnum}.timeInVols 
  if (myscreen.volnum - task{tnum}.thistrial.segstart) >= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
    segover = 1;
  end
  % check end of segment in seconds
else
  if (mglGetSecs-task{tnum}.thistrial.segstart) >= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
    % if we need to synch to volume
    if task{tnum}.synchToVol(task{tnum}.thistrial.thisseg)
      % then first time through set the volume number
      if task{tnum}.thistrial.synchVol == -1
	task{tnum}.thistrial.synchVol = myscreen.volnum;
	% then see if we have gone past that volume	
      elseif task{tnum}.thistrial.synchVol < myscreen.volnum
	segover = 1;
	% reset the segment time to match how much time elapsed
	% so that the next segment won't be shortened
	task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg) = mglGetSecs-task{tnum}.thistrial.segstart;
      end
      %w/out synch to volume the segment is over
    else
      segover = 1;
    end
  end
end

% there are situations in which for the trial in the sequence
% we are waiting for a volume to end the trial, but will enver
% get one since the scan is over. Yet, we still want to end the
% trial to end the experiment, so we are going to have fudge
% on the last volume. 
if task{tnum}.fudgeLastVolume
  % see if we are in the last trial for numTrials, or the
  % last trial of the last block for numBlocks
  if (task{tnum}.trialnum == task{tnum}.numTrials) || ...
	((task{tnum}.blocknum == task{tnum}.numBlocks) && (task{tnum}.blockTrialnum == task{tnum}.block(task{tnum}.blocknum).trialn))
    if ~isfield(task{tnum}.thistrial,'fudgeLastVolume')
      % see if we are in the last segment
      if task{tnum}.thistrial.thisseg == length(task{tnum}.thistrial.seglen)
	% make sure we have satisfied all but the last volume
	% for the trial (this could either be due to a synchToVol
	% waiting for the volume to end, or with timeInVols we have
	% gotten all but the last volume
	segmentExpired = 0;
	if task{tnum}.synchToVol(task{tnum}.thistrial.thisseg)
	  if task{tnum}.timeInTicks == 1
	    if (myscreen.tick - task{tnum}.thistrial.segstart) >= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
	      segmentExpired = 1;
	    end
	    % check end of segment in seconds
	  else
	    if (mglGetSecs-task{tnum}.thistrial.segstart) >= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
	      segmentExpired = 1;
	    end
	  end
	else
	  % check number of volumes
	  if task{tnum}.timeInVols 
	    if ((myscreen.volnum - task{tnum}.thistrial.segstart)+1) >= task{tnum}.thistrial.seglen(task{tnum}.thistrial.thisseg)
	      segmentExpired = 1;
	    end
	  end
	end
	% if segmentExpired gets set then it means that the segment has ended and
	% is just waiting for the volume (which will never come, so now we
	% set the fudgeLastVolume field so that it will end at 1 average volume
	% time away from now.
	if segmentExpired
	  % find the average volume time
	  volumeTimes = myscreen.events.time((myscreen.events.data == 1) & (myscreen.events.tracenum==1));
	  % we will only do this correction, if we can get
	  % a valid averageVolume Time
	  if ~isempty(volumeTimes)
	    % get time of last volume
	    task{tnum}.thistrial.averageVolumeTime = mean(diff(volumeTimes));
	    task{tnum}.thistrial.fudgeLastVolume = volumeTimes(end)+task{tnum}.thistrial.averageVolumeTime;
	  end
	end
      end
      % if there is a fudgeLastVolume field then it means
      % we should end the segment, once the proper amount of time has elapsed
      % this is the actual piece of code in here which causes the
      % segment to end by setting segover to 1
    else
      if mglGetSecs > task{tnum}.thistrial.fudgeLastVolume
	disp(sprintf('(updateTask) Used fudgeLastVolume to end last trial of task (averageVolumeTime=%0.2f)',task{tnum}.thistrial.averageVolumeTime));
	segover = 1;
      end
    end
  end
end

% update the segment if necessary
if (segover)
  % reset flush mode if we just finished a reactionTime response interval
  if (task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==2)
    myscreen.flushMode = myscreen.oldFlushMode;
  end
  % now update segment counter
  task{tnum}.thistrial.thisseg = task{tnum}.thistrial.thisseg + 1;
  % if we have completed all segments then we are done
  if (task{tnum}.thistrial.thisseg > length(task{tnum}.thistrial.seglen))
    % end the current trial
    if isfield(task{tnum}.callback,'endTrial')
      [task{tnum} myscreen]= feval(task{tnum}.callback.endTrial,task{tnum},myscreen);
    end
    if myscreen.eyetracker.init 
      %% call eyetracker endTrial callback
      [task{tnum} myscreen] = feval(myscreen.eyetracker.callback.endTrial,task{tnum},myscreen);
    end
    % if there are calculated random variables, save them
    if task{tnum}.randVars.calculated_n_
      for nVar = 1:task{tnum}.randVars.calculated_n_
	% check to make sure that the value in the calculated variable is not
	% set to empty (if it is, then we warn and ignore), otherwise
	% we set the stored calculated variable was set to (in the user
	% program) in task.thistrial
	if ~isempty(task{tnum}.thistrial.(task{tnum}.randVars.calculated_names_{nVar}))
	  if isscalar(task{tnum}.thistrial.(task{tnum}.randVars.calculated_names_{nVar}))
	    % scalar calculated var gets an array
	    eval(sprintf('task{tnum}.randVars.%s(task{tnum}.trialnum) = task{tnum}.thistrial.%s;',task{tnum}.randVars.calculated_names_{nVar},task{tnum}.randVars.calculated_names_{nVar}));
	  else
	    % non-scalar calculated var gets a *cell* array
	    eval(sprintf('task{tnum}.randVars.%s{task{tnum}.trialnum} = task{tnum}.thistrial.%s;',task{tnum}.randVars.calculated_names_{nVar},task{tnum}.randVars.calculated_names_{nVar}));
	  end
	else
	  disp(sprintf('(updateTask) !!! randVar %s set to empty for trial %i, leaving as default value of %s',task{tnum}.randVars.calculated_names_{nVar},task{tnum}.trialnum,task{tnum}.randVars.(task{tnum}.randVars.calculated_names_{nVar})(task{tnum}.trialnum)));
	end
      end
    end
    % we collect the calculated randVars from thistrial and place them
    % back into the randVar array.
    % this
    % update the trial number
    task{tnum}.blockTrialnum = task{tnum}.blockTrialnum + 1;
    task{tnum}.trialnum = task{tnum}.trialnum+1;
    % set the trial to init when it hits updateTrial again 
    % (this will happen from the updateTask called below)
    task{tnum}.thistrial.waitingToInit = 1;
    % now we have to update the task
    [task myscreen tnum] = updateTask(task,myscreen,tnum);
    % make sure that random number generator is in correct state
    if tnum<=length(task) & isfield(task{tnum},'randstate') 
      rand(task{tnum}.randstate.type,task{tnum}.randstate.state);
    end
    return
  end
  % restart segment clock
  task{tnum} = resetSegmentClock(task{tnum},myscreen);
  % write out appropriate trace
  myscreen = writeTrace(task{tnum}.thistrial.thisseg,task{tnum}.segmentTrace,myscreen,1);

  % call segment start callback
  if myscreen.eyetracker.init
    %% call eyetracker trial callback
    [task{tnum} myscreen] = feval(myscreen.eyetracker.callback.startSegment,task{tnum},myscreen);
  end
  [task{tnum} myscreen] = feval(task{tnum}.callback.startSegment,task{tnum},myscreen);
  % if this segment is set to getResponse(2), then it means that we 
  % are getting response and shutting down flipping of the screen
  % so that we can get better response time for reaction time tasks
  if (task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==2)
    % call the display funciton now, and flush screen
    [task{tnum} myscreen] = feval(task{tnum}.callback.screenUpdate,task{tnum},myscreen);
    mglFlush;
    % now set not update the screen while we wait for response
    myscreen.oldFlushMode = myscreen.flushMode;
    myscreen.flushMode = -1;
  end
end

% if we have to collect observer response, then look for that
if (task{tnum}.getResponse(task{tnum}.thistrial.thisseg))
  % check keyboard if that is what is being asked for (code 1 or 2) 1
  % is just keyboard check 2 is an old call for checking keyboard but
  % staying in a tight loop for gettine better reaction time data (not
  % necessary anymore because the keyboard events are being returned
  % by the system with nanosecond precision timing. 3 means get both
  % keyboard and mouse events and 4 means just mouse
  task{tnum}.thistrial.mouseButton = [];
  % get keyboard state
  buttons = ismember(myscreen.keyboard.nums,myscreen.keyCodes);
  if any(task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==[1 2 3])
    % if a button was pressed, then record response
    if (any(buttons) && (~isequal(buttons,task{tnum}.thistrial.buttonState)))
      % set the button state to pass
      task{tnum}.thistrial.buttonState = buttons;
      task{tnum}.thistrial.whichButton = find(buttons);
      task{tnum}.thistrial.whichButton = task{tnum}.thistrial.whichButton(1);
      % get the time of the button press
      whichKeyCode = find(myscreen.keyboard.nums(task{tnum}.thistrial.whichButton)==myscreen.keyCodes);
      responseTime = myscreen.keyTimes(whichKeyCode(1));
      % write out an event
      myscreen = writeTrace(task{tnum}.thistrial.whichButton,task{tnum}.responseTrace,myscreen,1,responseTime);
      % get reaction time
      task{tnum}.thistrial.reactionTime = responseTime-task{tnum}.thistrial.segStartSeconds;
      if isfield(task{tnum}.callback,'trialResponse')
	[task{tnum} myscreen] = feval(task{tnum}.callback.trialResponse,task{tnum},myscreen);
      end
      % set flush mode back
      if (task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==2)
	myscreen.flushMode = myscreen.oldFlushMode;
      end
      % and set that we have got a response
      task{tnum}.thistrial.gotResponse = task{tnum}.thistrial.gotResponse+1;
    end
  end
  % remember the current button state
  task{tnum}.thistrial.buttonState = buttons;
  % check mouse state if getResponse is set to 3
  if any(task{tnum}.getResponse(task{tnum}.thistrial.thisseg)==[3 4])
    % get the mouse state
    [task{tnum}.thistrial.mouseButton task{tnum}.thistrial.mouseWhen task{tnum}.thistrial.mouseX task{tnum}.thistrial.mouseY] = mglGetMouseEvent(0,1);
    % remove events that happened before this segment
    goodEvents = task{tnum}.thistrial.mouseWhen > task{tnum}.thistrial.segStartSeconds;
    if ~isempty(task{tnum}.thistrial.mouseButton)
      task{tnum}.thistrial.mouseButton = task{tnum}.thistrial.mouseButton(goodEvents);
      task{tnum}.thistrial.mouseWhen = task{tnum}.thistrial.mouseWhen(goodEvents);
      task{tnum}.thistrial.mouseX = task{tnum}.thistrial.mouseX(goodEvents);
      task{tnum}.thistrial.mouseY = task{tnum}.thistrial.mouseY(goodEvents);
    end
    % if there was a mouse down event
    if ~isempty(task{tnum}.thistrial.mouseButton)
      responseTime = task{tnum}.thistrial.mouseWhen;
      % write out an event (code the mouse events as negative numbers to
      % distinguish them from keyboard events
      myscreen = writeTrace(-task{tnum}.thistrial.mouseButton,task{tnum}.responseTrace,myscreen,1,responseTime);
      % get reaction time
      task{tnum}.thistrial.reactionTime = responseTime-task{tnum}.thistrial.segStartSeconds;
      if isfield(task{tnum}.callback,'trialResponse')
	[task{tnum} myscreen] = feval(task{tnum}.callback.trialResponse,task{tnum},myscreen);
      end
      % and set that we have got a response
      task{tnum}.thistrial.gotResponse = task{tnum}.thistrial.gotResponse+1;
    end
  end
end

% update the stimuli, but only if we are actually updating the screen
if myscreen.flushMode >= 0
  [task{tnum} myscreen] = feval(task{tnum}.callback.screenUpdate,task{tnum},myscreen);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% init block
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [task myscreen] = initBlock(task,myscreen,phase)

% start up a new block
% select a randomization of trial parameters
task.blocknum = task.blocknum+1;

% set the randstate here. This is so that the randomization that
% happens here is independent of other uses of the rand variable
% that way if you want to recreate the order of trials, you
% can reset the rand state in initTask from the one that is saved
randstate = rand(task.randstate.type);
rand(task.randstate.type,task.randstate.blockState);

% update the parameter order for this block
% using the randomization callback, if this
% pass previous block if it is available
if task.blocknum > 1
  task.block(task.blocknum) = feval(task.callback.rand,task.parameter,task.block(task.blocknum-1));
else
  task.block(task.blocknum) = feval(task.callback.rand,task.parameter,[]);
end

% now keep the randstate
task.randstate.blockState = rand(task.randstate.type);
rand(task.randstate.type,randstate);

% set the initial trial
task.blockTrialnum = 1;

% call the init block callback
if isfield(task.callback,'startBlock')
  [task myscreen] = feval(task.callback.startBlock,task,myscreen);
end
if myscreen.eyetracker.init
  %% call eyetracker block callback
  [task myscreen] = feval(myscreen.eyetracker.callback.startBlock,task,myscreen);
end

% set up start time to tell routines to init trial properly
% only init new trials if the number of trials is less than or equal to
% orig trials

[task myscreen] = initTrial(task,myscreen,phase);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% init trial
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [task, myscreen] = initTrial(task,myscreen,phase) 

% keep lasttrial information
task.lasttrial = task.thistrial;

%only update randvars if this is a new trial and not a trial that is been
% if task.trialnum <= task.origNumTrials
    % get randomization parameters
    for i = 1:task.randVars.n_
        % get the variable name we are working on
        thisRandVarName = task.randVars.names_{i};
        if iscell(task.randVars.(thisRandVarName))
            % if the precomputed list is a cell array then grab from that cell array
            task.thistrial.(thisRandVarName) = task.randVars.(thisRandVarName){mod(task.trialnum-1,task.randVars.varlen_(i))+1};
        else
            % otherwise grab from a regular array
            task.thistrial.(thisRandVarName) = task.randVars.(thisRandVarName)(mod(task.trialnum-1,task.randVars.varlen_(i))+1);
        end
    end
% else
%     task.thistrial = task.fixBreakTrial(stimulus.trialnum-task.origNumTrials);
% end

% recreate all other trialvars regardless of whether this is a new or a
% reused trial

% set the phase num of the trial
task.thistrial.thisphase = phase;

% set the segment number
task.thistrial.thisseg = 1;
task.thistrial.gotResponse = 0;

% restart segment clock
task.thistrial.segstart = -inf;

% start trial time
%if (task.timeInTicks)
%  task.thistrial.trialstart = myscreen.tick;
%elseif (task.timeInVols)
%  task.thistrial.trialstart = myscreen.volnum;
%else
%end

% set up start volume for checking for backticks
task.thistrial.startvolnum = myscreen.volnum;


% here we deal with precomputed seglen
if isequal(task.seglenPrecompute,false)
    % set the segment length
    [seglen task] = getTaskSeglen(task);
    task.thistrial.seglen = seglen;
else
    % note that if seglens are precomputed, also anything else having to do
    % with semgents need to be recomputed (i.e. you may want to compute
    % synchToVol or getResponse on a trial by trial basis - for example,
    % you may have trials in which on different trials the synchToVol changes
    % or which segment is the response segment changes.Whatever fields
    % there are in seglenPrecompute get placed into task at this stage
    for iField = 1:task.seglenPrecompute.nFields
        % get the name of the field getting set from precompute
        fieldName = (task.seglenPrecompute.fieldNames{iField});
        % get what cell to take (i.e. if the field only has one row
        % then we will take that otherwise there should be one cell for
        % each trial) If we have multiple trials, but less than the current
        % trial number than cycle through the rows
        fieldRow = mod(task.trialnum-1,task.seglenPrecompute.(fieldName).nTrials)+1;
        task.thistrial.(fieldName) = task.seglenPrecompute.(fieldName).vals{fieldRow};
    end
    % now get the seglen for this trial (note that seglen is a cell array
    % which allows for trials with different numbers of segments)
    fieldRow = mod(task.trialnum-1,task.seglenPrecompute.seglen.nTrials)+1;
    task.thistrial.seglen = task.seglenPrecompute.seglen.vals{fieldRow};
end


% see if we need to wait for backtick
if task.waitForBacktick && (task.blocknum == 1) && (task.blockTrialnum == 1)
  task.thistrial.waitForBacktick = 1;
  backtick = mglKeycodeToChar(myscreen.keyboard.backtick);
  disp(sprintf('(updateTask) Waiting for backtick (%s)',backtick{1}));
else
  % trial will start right awway
  task.thistrial.waitForBacktick = 0;
end

% set the button states to zero
task.thistrial.buttonState = [0 0];

% get trial parameters
for i = 1:task.parameter.n_
  eval(sprintf('task.thistrial.%s = task.block(task.blocknum).parameter.%s(:,task.blockTrialnum);',task.parameter.names_{i},task.parameter.names_{i}));
end


% call the init trial callback
if isfield(task.callback,'startTrial')
  [task myscreen] = feval(task.callback.startTrial,task,myscreen);
end    
if myscreen.eyetracker.init
  %% call eyetracker trial callback
  [task myscreen] = feval(myscreen.eyetracker.callback.startTrial,task,myscreen);
end

% the trial is no longer waiting to start
task.thistrial.waitingToInit = 0;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% function to reset segment time
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function task = resetSegmentClock(task,myscreen)

% reset the synch volume
task.thistrial.synchVol = -1;

% get amount of time already used, including and
% discrepancy left over from last trial
usedtime = sum(task.thistrial.seglen(1:(task.thistrial.thisseg-1)));

% restart segment clock, if we are using seconds, then fix
% any time discrepancy
if ~(task.timeInVols || task.timeInTicks)
  task.thistrial.segstart = task.thistrial.trialstart-task.timeDiscrepancy+usedtime;
else
  task.thistrial.segstart = task.thistrial.trialstart+usedtime;
end
% get start of segment in real seconds
task.thistrial.segStartSeconds = mglGetSecs;


##### SOURCE END #####
--></body></html>